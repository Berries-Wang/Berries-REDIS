# 使用Redis实现分布式锁细节-Redis集群
## Redis 集群下问题
1. 客户端A从master获取到锁
2. 在master将锁同步到slave之前，master宕机。
3. slave节点被晋级为master节点
4. 客户端B取得了与客户端A相同的临界资源，此时就发生了并发问题。

## 集群解决方案: The Redlock Algorithm
&nbsp;&nbsp;在算法的分布式版本中，我们假设有N个Redis Master节点。这些节点完全项目独立。所以我们不使用复制或其他隐式协调系统。如文档所言，我们早已描述了如何在单实例中安全地申请和释放锁。我们假定算法将使用这种方法在单个实例中获取和释放锁。在我们的例子中，我们设置N=5，所以我们需要运行5个Redis Master节点在不用的计算机或者虚拟机上，以确保他们以独立的方式发生故障。

&nbsp;&nbsp;为了申请分布式锁，客户端需要执行如下操作:
- step-1. 获取当前时间的毫秒值。
- step-2. 客户端尝试在所有的N个实例中使用相同的K-V依次申请锁，在Step-2期间，当在每个实例上设置锁的时候，客户端使用超时时间，该超时时间小于锁自动释放的时间。例如，如果锁10S之后自动释放，那么这个超时时间应该在 5~50毫秒之间。这可以防止客户端在尝试与一个宕机的Redis节点通信时长时间处于阻塞状态:如果一个实例不可用，我们应该尽快尝试与下一个实例通信
- step-3. 客户端计算获取锁所需要的时间，通过将当前时间与step-1获取到的时间相减，当且仅当客户端能够在大多数实例(至少3个)<sup>该例子中，总节点数为5</sup>中获得锁，并且获得锁的总时间小于锁的有效时间，则认为该锁已获得。
- step-4: 如果获得了锁，则认为锁的有效时间为初始有效时间减去经过的时间，如步骤3中计算的那样。
- step-5: 如果客户端因为某些原因获取锁失败，那么会尝试对所有实例进行解锁(尽管没有对该实例加锁成功)。
  + 失败原因:
     1. 锁有效时间为负数
     2. 获取锁的实例数小于 (N/2 +1)


---

## 参考资料
1. [the-redlock-algorithm](https://redis.io/docs/manual/patterns/distributed-locks/#the-redlock-algorithmi)