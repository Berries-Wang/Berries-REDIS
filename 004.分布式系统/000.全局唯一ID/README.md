# 分布式系统-全局唯一ID实现方案
## 为什么需要全局唯一ID
&nbsp;&nbsp;在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况就需要全局唯一ID来保证数据的唯一性。（如订单ID）

## 全局唯一ID实现方案
### 方案-UUID
&nbsp;&nbsp;UUID （Universally Unique Identifier），通用唯一识别码的缩写。UUID是由一组32位数的16进制数字所构成，所以UUID理论上的总数为 16^32=2^128，约等于 3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。

#### UUID 优缺点
1. UUID 生成方便，本地生成没有网络消耗
2. 不易存储： UUID太长，16字节128位，通常以36长度字符串表示，很多场景不适用。
3. 信息不安全：基于mac地址生成UUID的算法可能会造成mac地址泄露，暴露使用者位置。
4. 对MySQL索引不利，如果作为数据库的主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能。

### 方案-数据库生成
&nbsp;&nbsp;由于分布式数据库的起始自增值一样所以才会有冲突的情况发生，那么我们将分布式系统中数据库的同一个业务表的自增ID设计成不一样的起始值，然后设置固定的步长，步长的值即为分库的数量或分表的数量。


&nbsp;&nbsp;以MySQL举例，利用给字段设置auto_increment_increment和auto_increment_offset来保证ID自增。
- auto_increment_offset：表示自增长字段从那个数开始，他的取值范围是1 .. 65535。
- auto_increment_increment：表示自增长字段每次递增的量，其默认值是1，取值范围是1 .. 65535。

&nbsp;&nbsp;假设有三台机器，则DB1中order表的起始ID值为1，DB2中order表的起始值为2，DB3中order表的起始值为3，它们自增的步长都为3，则它们的ID生成范围如下图所示：

---

### 方案-基于Redis实现


---

### 方案-雪花算法-Snowflake

## 对于算法的考量
1. 无论是什么样的全局唯一 ID 生成算法，都会有优点和缺点。在实际的应用当中，没有人会将全局唯一 ID 生成算法完全托付给程序，而是会用数据库存储关键值或者所有生成的值。全局唯一 ID 生成算法大多都采用分布式架构或者主备架构提供发号服务，这时候就不用担心它的重复问题；