# Redis缓存
## 01. 收益
1. 加速读写
2. 降低后端负载

## 02. 成本
1. 数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关
2. 代码维护成本：多了一层缓存逻辑
3. 运维成本，运维redis clusterr

## 03. 使用场景
1. 降低后端负载
    - 对高消耗SQL： join结果集/分组统计结果进行缓存
2. 加速请求响应
    - 利用Redis优化I/O响应时间
3. 大量写合并为批量写
    - 如计数器先Redis累加再批量写DB

## 04. 缓存更新策略
1. LRU/LIRS算法剔除，即最大内存和淘汰策略
    - 6种淘汰策略：
      1. volatile-lru：从设置过期时间的数据集(server.db[i].expires)中挑选出最近最少使用的数据淘汰。没有设置过期时间的key不会被淘汰，这样就可以在增加内存空间的同时保证需要持久化的数据不会丢失。
      2. volatile-ttl：除了淘汰机制采用LRU，策略基本上与volatile-lru相似，从设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰。
      3. volatile-random：从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰。当内存达到限制无法写入非过期时间的数据集时，可以通过该淘汰策略在主键空间中随机移除某个key。
      4. allkeys-lru：从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰，该策略要淘汰的key面向的是全体key集合，而非过期的key集合。
      5. allkeys-random：从数据集(server.db[i].dict)中选择任意数据淘汰。
      6. no-enviction：禁止驱逐数据，也就是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失，这也是系统默认的一种淘汰策略。
2. 超时剔除
3. 主动更新

#### 更新策略的选择
1. 低一致性： 最大内存和淘汰策略。
2. 高一致性： 超时剔除和主动更新结合，最大内存和淘汰策略为备选手段

### 05. 缓存穿透
&nbsp;&nbsp;什么是缓存穿透
- 即数据库中本就不存在的数据，自然在Redis中也不存在，这就会导致客户端直接访问了存储层(MySQL)

#### 原因
1. 代码本身有问题
2. 恶意攻击，爬虫

### 06. 缓存击穿
&nbsp;&nbsp;缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力.

#### 解决方式：
1. 设置热点数据永远不过期。
2. 维护缓存时加锁

### 07. 缓存雪崩
&nbsp;&nbsp;缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是,缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

#### 解决方式：
1. 设置热点数据永远不过期。
